<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural 3D Solar System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Procedural 3D Solar System</h1>
        <p>Left Click: Rotate | Right Click: Pan | Scroll: Zoom</p>
    </div>
    <div id="loading">Generating Universe...</div>

    <!-- Import maps polyfill -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const SCENE_CONFIG = {
            sunSize: 5,
            orbitScale: 10, // Scale distance for visibility
            planetScale: 1, // Scale planets for visibility
            speedScale: 0.5
        };

        const PLANETS = [
            { name: "Mercury", radius: 0.38, distance: 0.39, color: 0xA5A5A5, speed: 4.74 },
            { name: "Venus", radius: 0.95, distance: 0.72, color: 0xE3BB76, speed: 3.50 },
            { name: "Earth", radius: 1.00, distance: 1.00, color: 0x2233FF, speed: 2.98, hasMoon: true },
            { name: "Mars", radius: 0.53, distance: 1.52, color: 0xDD4422, speed: 2.41 },
            { name: "Jupiter", radius: 3.00, distance: 2.50, color: 0xD9A066, speed: 1.31 }, // Distance compressed
            { name: "Saturn", radius: 2.50, distance: 3.50, color: 0xF4D03F, speed: 0.97, hasRings: true },
            { name: "Uranus", radius: 1.80, distance: 4.50, color: 0x4FD0E7, speed: 0.68 },
            { name: "Neptune", radius: 1.75, distance: 5.50, color: 0x2244FF, speed: 0.54 }
        ];

        // --- Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 30, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Helpers ---
        function createTexture(color, noise = true) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base color
            ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
            ctx.fillRect(0, 0, 512, 512);

            if (noise) {
                // Add noise
                const imageData = ctx.getImageData(0, 0, 512, 512);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const grain = (Math.random() - 0.5) * 40;
                    data[i] = Math.min(255, Math.max(0, data[i] + grain));
                    data[i+1] = Math.min(255, Math.max(0, data[i+1] + grain));
                    data[i+2] = Math.min(255, Math.max(0, data[i+2] + grain));
                }
                ctx.putImageData(imageData, 0, 0);
                
                // Add bands for gas giants look
                ctx.globalCompositeOperation = 'overlay';
                const gradient = ctx.createLinearGradient(0, 0, 0, 512);
                for(let i=0; i<5; i++) {
                    gradient.addColorStop(Math.random(), `rgba(255,255,255,${Math.random()*0.3})`);
                    gradient.addColorStop(Math.random(), `rgba(0,0,0,${Math.random()*0.3})`);
                }
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);
            }

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function createRingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createLinearGradient(0, 0, 0, 64);
            gradient.addColorStop(0, 'rgba(255,255,255,0)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.1)');
            gradient.addColorStop(0.8, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.rotation = Math.PI / 2;
            return texture;
        }

        // --- Objects ---

        // Sun
        const sunGeometry = new THREE.SphereGeometry(SCENE_CONFIG.sunSize, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xFFDD00,
            map: createTexture(0xFFDD00, true)
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);

        // Sun Glow
        const sunLight = new THREE.PointLight(0xffffff, 3, 300, 0.5);
        scene.add(sunLight);
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Starfield
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 5000;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) {
            starPos[i] = (Math.random() - 0.5) * 400;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Planets
        const planetMeshes = [];
        const orbits = [];

        PLANETS.forEach(data => {
            const orbitGroup = new THREE.Group();
            scene.add(orbitGroup);
            orbits.push({ group: orbitGroup, speed: data.speed * SCENE_CONFIG.speedScale });

            // Orbit path visualization
            const pathGeo = new THREE.RingGeometry(
                (data.distance * SCENE_CONFIG.orbitScale) - 0.05, 
                (data.distance * SCENE_CONFIG.orbitScale) + 0.05, 
                64
            );
            const pathMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.1 });
            const path = new THREE.Mesh(pathGeo, pathMat);
            path.rotation.x = Math.PI / 2;
            scene.add(path);

            // Planet
            const geometry = new THREE.SphereGeometry(data.radius * SCENE_CONFIG.planetScale, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                map: createTexture(data.color),
                roughness: 0.7,
                metalness: 0.1
            });
            const planet = new THREE.Mesh(geometry, material);
            planet.position.x = data.distance * SCENE_CONFIG.orbitScale;
            orbitGroup.add(planet);
            
            // Store for self-rotation
            planetMeshes.push(planet);

            // Rings (Saturn)
            if (data.hasRings) {
                const ringGeo = new THREE.RingGeometry(
                    (data.radius * SCENE_CONFIG.planetScale) + 0.5,
                    (data.radius * SCENE_CONFIG.planetScale) + 2.5,
                    64
                );
                const ringMat = new THREE.MeshBasicMaterial({ 
                    map: createRingTexture(),
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                planet.add(ring);
            }

            // Moon (Earth)
            if (data.hasMoon) {
                const moonGeo = new THREE.SphereGeometry(0.3 * SCENE_CONFIG.planetScale, 16, 16);
                const moonMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
                const moon = new THREE.Mesh(moonGeo, moonMat);
                moon.position.x = 2 * SCENE_CONFIG.planetScale;
                planet.add(moon);
                // Simple moon animation handled in loop
                planet.userData = { moon: moon };
            }
        });

        // --- Animation ---
        document.getElementById('loading').style.opacity = 0;
        
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Rotate Sun
            sun.rotation.y += 0.002;

            // Rotate Planets around Sun
            orbits.forEach(orbit => {
                orbit.group.rotation.y += orbit.speed * delta * 0.1;
            });

            // Rotate Planets on axis
            planetMeshes.forEach(planet => {
                planet.rotation.y += 0.5 * delta;
                
                // Animate Moon
                if (planet.userData.moon) {
                    const moon = planet.userData.moon;
                    moon.position.x = Math.cos(time * 2) * 2.5;
                    moon.position.z = Math.sin(time * 2) * 2.5;
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // --- Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>